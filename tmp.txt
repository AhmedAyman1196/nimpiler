// ------------------------------ Grammar --------------------------------------

module : (stmt ((';' | INDENT) stmt)*)? ;
//module : (stmt ((';' | INDENT) stmt)*)? ;
module : literal;
stmt : varStmt ;

comma : ',' COMMENT? ;
semicolon : ';' COMMENT? ;
colon : ':' COMMENT? ;
colcom : ':' COMMENT? ;
operator :  OP0 | OP1 | OP2 | OP3 | OP4 | OP5 | OP6 | OP7 | OP8 | OP9
        | 'or' | 'xor' | 'and'
        | 'is' | 'isnot' | 'in' | 'notin' | 'of'
        | 'div' | 'mod' | 'shl' | 'shr' | 'not' | 'static' | '..' ;

OP10 : '^';
OP9 : MUL_OPERATOR | DIV_OPERATOR | DIV | SHL | SHR | MODULUS;
OP8 : ADD_OPERATOR | MINUS_OPERATOR;
OP7 : AND_OPERATOR;
OP6 : '..';
OP5 : '==' | '<=' | '<' | '>=' | '>' | '!=' | IN | NOTIN | IS | ISNOT | NOT | OF;
OP4 : AND;
OP3 : OR | XOR;
OP2 : AT | COLON | '?';
OP1 : '=' | '+=' | '-=' | '*=' | '/=';
OP0 : '->' | '~>' | '=>';
opr : OP9 | OP8;

prefixOperator : operator ;
optInd : COMMENT? INDENT ;
optPar : (INDENT | INDENT)? ;

simpleExpr : arrowExpr (OP0 optInd arrowExpr)* pragma? ;
arrowExpr : assignExpr (OP1 optInd assignExpr)* ;
assignExpr : orExpr (OP2 optInd orExpr)* ;
orExpr : andExpr (OP3 optInd andExpr)*;
andExpr : cmpExpr (OP4 optInd cmpExpr)* ;
cmpExpr : sliceExpr (OP5 optInd sliceExpr)*;
sliceExpr : ampExpr (OP6 optInd ampExpr)* ;
ampExpr : plusExpr (OP7 optInd plusExpr)* ;
plusExpr : mulExpr (OP8 optInd mulExpr)* ;
mulExpr : dollarExpr (OP9 optInd dollarExpr)* ;
dollarExpr : primary (OP10 optInd primary)* ;
symbol : ('`' (KEYW|ident|literal|(operator|'('|')'|'['|']'|'{'|'}'|'=')+)+ '`') | ident | KEYW ;

exprColonEqExpr : expr (':'|'=' expr)?;

exprList : expr (comma expr)* ;

exprColonEqExprList : exprColonEqExpr (comma exprColonEqExpr)* (comma)? ;
dotExpr : expr '.' optInd (symbol | '[:' exprList ']') ;
explicitGenericInstantiation : '[:' exprList ']' ( '(' exprColonEqExpr ')' )? ;
qualifiedIdent : symbol ('.' optInd symbol)? ;
setOrTableConstr : '{' ((exprColonEqExpr comma)* | ':' ) '}' ;
castExpr : 'cast' '[' optInd typeDesc optPar ']' '(' optInd expr optPar ')' ;
parKeyw : 'discard' | 'include' | 'if' | 'while' | 'case' | 'try'
       | 'finally' | 'except' | 'for' | 'block' | 'const' | 'let'
       | 'when' | 'var' | 'mixin' ;


par : '(' optInd
         ( complexOrSimpleStmt (';' complexOrSimpleStmt)*
         | ';' complexOrSimpleStmt (';' complexOrSimpleStmt)*
         | pragmaStmt
         | simpleExpr ( ('=' expr (';' complexOrSimpleStmt (';' complexOrSimpleStmt)* )? )
                      | (':' expr (',' exprColonEqExpr (',' exprColonEqExpr)* )? ) ) )
         optPar ')' ;
varStmt : VARIABLE IDENTIFIER (COMMA IDENTIFIER)* ((COLON predefType) | ('=' literal))?;

literal : INT_LIT | INT8_LIT | INT16_LIT | INT32_LIT | INT64_LIT
         | UINT_LIT | UINT8_LIT | UINT16_LIT | UINT32_LIT | UINT64_LIT
         | FLOAT_LIT | FLOAT32_LIT | FLOAT64_LIT
         | STR_LIT | RSTR_LIT | TRIPLESTR_LIT
         | CHAR_LIT
         | NIL ;
generalizedLit : GENERALIZED_STR_LIT | GENERALIZED_TRIPLESTR_LIT ;
identOrLiteral : generalizedLit | symbol | literal
              | par | arrayConstr | setOrTableConstr
              | castExpr ;
tupleConstr : '(' optInd (exprColonEqExpr comma?)* optPar ')' ;
arrayConstr : '[' optInd (exprColonEqExpr comma?)* optPar ']' ;

primarySuffix : '(' (exprColonEqExpr comma?)* ')' doBlocks?
     | doBlocks
     | '.' optInd symbol generalizedLit?
     | '[' optInd indexExprList optPar ']'
     | '{' optInd indexExprList optPar '}'
     | expr;

indexExprList : indexExpr (comma indexExpr)*;
indexExpr : expr;

macroColon : ':' stmt? ( INDENT 'of' exprList ':' stmt
                      | INDENT 'elif' expr ':' stmt
                      | INDENT 'except' exprList ':' stmt
                      | INDENT 'else' ':' stmt )*;

moduleName : IDENTIFIER ('.'IDENTIFIER)*?;

exportStmt : 'import' optInd expr
             ((comma expr)*
             | 'except' optInd (expr (comma expr)*)) ;

ident : IDENTIFIER (comma IDENTIFIER)*;

doBlocks : (doBlock (INDENT doBlock)*);

caseExpr : caseStmt;

condExpr : expr colcom expr optInd
       ('elif' expr colcom expr optInd)*
        'else' colcom expr ;
ifExpr : 'if' condExpr ;
whenExpr : 'when' condExpr ;
pragma : '{.' optInd (exprColonEqExpr comma?)* optPar ('.}' | '}') ;

identVis : symbol opr?;

identVisDot : symbol '.' optInd symbol opr? ;
identWithPragma : identVis pragma? ;
identWithPragmaDot : identVisDot pragma? ;
declColonEquals : identWithPragma (comma identWithPragma)* comma?
                 (':' optInd typeDesc)? ('=' optInd expr)? ;
identColonEquals : ident (comma ident)* comma?
    (':' optInd typeDesc)? ('=' optInd expr)? ;

inlTupleDecl : 'tuple'
   '[' optInd  (identColonEquals (comma/semicolon)?)*  optPar ']' ;

extTupleDecl : 'tuple'
   COMMENT? (INDENT identColonEquals (INDENT identColonEquals)*)? ;
tupleClass : 'tuple' ;

paramList : '(' (declColonEquals ((comma'/'semicolon) declColonEquals)*)? ')' ;

paramListArrow : paramList? ('->' optInd typeDesc)? ;
paramListColon : paramList? (':' optInd typeDesc)? ;
doBlock : 'do' paramListArrow pragma? colcom stmt ;
procExpr : 'proc' paramListColon pragma? ('=' COMMENT? stmt)? ;
distinct : 'distinct' optInd typeDesc ;

forStmt : 'for' (identWithPragma (comma identWithPragma)*) 'in' expr colcom stmt ;
forExpr : forStmt ;


expr : (blockExpr
     | ifExpr
     | whenExpr
     | caseExpr
     | forExpr
     | tryExpr)
     | simpleExpr ;
typeKeyw : 'var' | 'out' | 'ref' | 'ptr' | 'shared' | 'tuple'
        | 'proc' | 'iterator' | 'distinct' | 'object' | 'enum' ;

primary : typeKeyw typeDesc
       | prefixOperator* identOrLiteral primarySuffix*
       | 'bind' primary ;


typeDesc : simpleExpr ;
typeDefAux : simpleExpr
          | 'concept' typeClass ;
postExprBlocks : ':' stmt? ( INDENT doBlock
                          | INDENT 'of' exprList ':' stmt
                          | INDENT 'elif' expr ':' stmt
                          | INDENT 'except' exprList ':' stmt
                          | INDENT 'else' ':' stmt )* ;


exprStmt : simpleExpr (( '=' optInd expr colonBody? )
                    | ( expr (comma expr)* doBlocks | macroColon))? ;

importStmt : 'import' optInd expr
             ((comma expr)*
             | 'except' optInd (expr (comma expr)*)) ;

includeStmt : 'include' optInd expr (comma expr)* ;

fromStmt : 'from' moduleName 'import' optInd expr (comma expr)* ;
returnStmt : 'return' optInd expr? ;
raiseStmt : 'raise' optInd expr? ;
yieldStmt : 'yield' optInd expr? ;
discardStmt : 'discard' optInd expr? ;
breakStmt : 'break' optInd expr? ;
continueStmt : 'break' optInd expr? ;
condStmt : expr colcom stmt COMMENT?
          (INDENT 'elif' expr colcom stmt)*
          (INDENT 'else' colcom stmt)? ;
ifStmt : 'if' condStmt  ;
whenStmt : 'when' condStmt ;
whileStmt : 'while' expr colcom stmt ;
ofBranch : 'of' exprList colcom stmt ;
ofBranches : ofBranch (INDENT ofBranch)*
                     (INDENT 'elif' expr colcom stmt)*
                     (INDENT 'else' colcom stmt)? ;
caseStmt : 'case' expr ':'? COMMENT?
           (INDENT ofBranches
           | INDENT ofBranches) ;

tryStmt : 'try' colcom stmt
          (INDENT? 'except' exprList colcom stmt)*
          (INDENT? 'finally' colcom stmt)? ;

tryExpr : 'try' colcom stmt
          (optInd 'except' exprList colcom stmt)*
          (optInd 'finally' colcom stmt)? ;

exceptBlock : 'except' colcom stmt ;
blockStmt : 'block' symbol? colcom stmt ;
blockExpr : 'block' symbol? colcom stmt ;
staticStmt : 'static' colcom stmt ;
deferStmt : 'defer' colcom stmt ;
asmStmt : 'asm' pragma? (STR_LIT | RSTR_LIT | TRIPLESTR_LIT) ;
genericParam : symbol (comma symbol)* (colon expr)? ('=' optInd expr)? ;

genericParamList : '[' optInd
 (genericParam ((comma|semicolon) genericParam)*)? optPar ']' ;

pattern : '{' stmt '}' ;
indAndComment : (INDENT COMMENT)? | COMMENT? ;
routine : optInd identVis pattern? genericParamList?
 paramListColon pragma? ('=' COMMENT? stmt)? indAndComment ;
commentStmt : COMMENT ;

sectionTypeDef : COMMENT? typeDef | (INDENT (typeDef | COMMENT) (INDENT (typeDef | COMMENT))* ) ;
sectionConstant : COMMENT? constant | (INDENT (constant | COMMENT) (INDENT (constant | COMMENT))* ) ;
sectionVariable : COMMENT? variable | (INDENT (variable | COMMENT) (INDENT (variable | COMMENT))* ) ;

constant : identWithPragma (colon typeDesc)? '=' optInd expr indAndComment ;
enum : 'enum' optInd (symbol optInd ('=' optInd expr COMMENT?)? comma?)+ ;
objectWhen : 'when' expr colcom objectPart COMMENT?
           ('elif' expr colcom objectPart COMMENT?)*
           ('else' colcom objectPart COMMENT?)? ;
objectBranch : 'of' exprList colcom objectPart ;
objectBranches : objectBranch (INDENT objectBranch)*
                     (INDENT 'elif' expr colcom objectPart)*
                     (INDENT 'else' colcom objectPart)? ;
objectCase : 'case' identWithPragma ':' typeDesc ':'? COMMENT?
           (INDENT objectBranches
           | INDENT objectBranches) ;

objectPart : INDENT objectPart (INDENT objectPart)*
          | objectWhen | objectCase | 'nil' | 'discard' | declColonEquals ;

objectX : 'object' pragma? ('of' typeDesc)? COMMENT? objectPart ;
typeClassParam : ('var' | 'out')? symbol ;

typeClass : (typeClassParam (',' typeClassParam)*)? (pragma)? ('of' (typeDesc (',' typeDesc)*)?)?
             | stmt ;

typeDef : identWithPragmaDot genericParamList? '=' optInd typeDefAux
           indAndComment? ;

varTuple : '(' optInd identWithPragma (comma identWithPragma)* optPar ')' '=' optInd expr ;

colonBody : colcom stmt doBlocks? ;

variable : (varTuple | identColonEquals) colonBody? indAndComment ;

bindStmt : 'bind' optInd qualifiedIdent (comma qualifiedIdent)* ;

mixinStmt : 'mixin' optInd qualifiedIdent (comma qualifiedIdent)* ;

pragmaStmt : pragma (':' COMMENT? stmt)? ;

simpleStmt : ((returnStmt | raiseStmt | yieldStmt | discardStmt | breakStmt
          | continueStmt | pragmaStmt | importStmt | exportStmt | fromStmt
          | includeStmt | commentStmt) | exprStmt) COMMENT? ;

complexOrSimpleStmt : (ifStmt | whenStmt | whileStmt
                   | tryStmt | forStmt
                   | blockStmt | staticStmt | deferStmt | asmStmt
                   | 'proc' routine
                   | 'method' routine
                   | 'iterator' routine
                   | 'macro' routine
                   | 'template' routine
                   | 'converter' routine
                   | 'type' sectionTypeDef
                   | 'const' sectionConstant
                   | ('let' | 'var' | 'using') sectionVariable
                   | bindStmt | mixinStmt)
                   | simpleStmt ;

         | NIL

stmt : (INDENT complexOrSimpleStmt ((INDENT | ';') complexOrSimpleStmt)* )
    | simpleStmt (';' simpleStmt)* ;
predefType : 'int';
